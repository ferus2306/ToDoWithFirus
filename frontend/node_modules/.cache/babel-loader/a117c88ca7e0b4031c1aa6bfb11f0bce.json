{"ast":null,"code":"/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * @example\n * import { isTextField } from \"reakit-utils\";\n *\n * isTextField(document.querySelector(\"div\")); // false\n * isTextField(document.querySelector(\"input\")); // true\n * isTextField(document.querySelector(\"input[type='button']\")); // false\n * isTextField(document.querySelector(\"textarea\")); // true\n * isTextField(document.querySelector(\"div[contenteditable='true']\")); // true\n */\nfunction isTextField(element) {\n  try {\n    var isTextInput = element instanceof HTMLInputElement && element.selectionStart !== null;\n    var isTextArea = element.tagName === \"TEXTAREA\";\n    var isContentEditable = element.contentEditable === \"true\";\n    return isTextInput || isTextArea || isContentEditable || false;\n  } catch (error) {\n    // Safari throws an exception when trying to get `selectionStart`\n    // on non-text <input> elements (which, understandably, don't\n    // have the text selection API). We catch this via a try/catch\n    // block, as opposed to a more explicit check of the element's\n    // input types, because of Safari's non-standard behavior. This\n    // also means we don't have to worry about the list of input\n    // types that support `selectionStart` changing as the HTML spec\n    // evolves over time.\n    return false;\n  }\n}\n\nexport { isTextField };","map":{"version":3,"sources":["/Users/firushanov/Desktop/Kadince/todowithfirus/frontend/node_modules/reakit-utils/es/isTextField.js"],"names":["isTextField","element","isTextInput","HTMLInputElement","selectionStart","isTextArea","tagName","isContentEditable","contentEditable","error"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAT,CAAqBC,OAArB,EAA8B;AAC5B,MAAI;AACF,QAAIC,WAAW,GAAGD,OAAO,YAAYE,gBAAnB,IAAuCF,OAAO,CAACG,cAAR,KAA2B,IAApF;AACA,QAAIC,UAAU,GAAGJ,OAAO,CAACK,OAAR,KAAoB,UAArC;AACA,QAAIC,iBAAiB,GAAGN,OAAO,CAACO,eAAR,KAA4B,MAApD;AACA,WAAON,WAAW,IAAIG,UAAf,IAA6BE,iBAA7B,IAAkD,KAAzD;AACD,GALD,CAKE,OAAOE,KAAP,EAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAO,KAAP;AACD;AACF;;AAED,SAAST,WAAT","sourcesContent":["/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * @example\n * import { isTextField } from \"reakit-utils\";\n *\n * isTextField(document.querySelector(\"div\")); // false\n * isTextField(document.querySelector(\"input\")); // true\n * isTextField(document.querySelector(\"input[type='button']\")); // false\n * isTextField(document.querySelector(\"textarea\")); // true\n * isTextField(document.querySelector(\"div[contenteditable='true']\")); // true\n */\nfunction isTextField(element) {\n  try {\n    var isTextInput = element instanceof HTMLInputElement && element.selectionStart !== null;\n    var isTextArea = element.tagName === \"TEXTAREA\";\n    var isContentEditable = element.contentEditable === \"true\";\n    return isTextInput || isTextArea || isContentEditable || false;\n  } catch (error) {\n    // Safari throws an exception when trying to get `selectionStart`\n    // on non-text <input> elements (which, understandably, don't\n    // have the text selection API). We catch this via a try/catch\n    // block, as opposed to a more explicit check of the element's\n    // input types, because of Safari's non-standard behavior. This\n    // also means we don't have to worry about the list of input\n    // types that support `selectionStart` changing as the HTML spec\n    // evolves over time.\n    return false;\n  }\n}\n\nexport { isTextField };\n"]},"metadata":{},"sourceType":"module"}